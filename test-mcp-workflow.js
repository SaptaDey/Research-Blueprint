#!/usr/bin/env node

/**
 * Comprehensive MCP Server Workflow Test
 * Tests the complete workflow including error handling and fix verification
 */

import { spawn } from 'child_process';
import { setTimeout } from 'timers/promises';

class MCPWorkflowTester {
  constructor() {
    this.testResults = [];
    this.contextId = null;
  }

  async runAllTests() {
    console.log('üîß Testing Complete MCP Server Workflow...\n');
    
    const tests = [
      { name: 'Basic Analysis Execution', method: this.testBasicAnalysis.bind(this) },
      { name: 'Context Status Check', method: this.testStatusCheck.bind(this) },
      { name: 'Subgraph Extraction', method: this.testSubgraphExtraction.bind(this) },
      { name: 'Graph Validation', method: this.testGraphValidation.bind(this) },
      { name: 'Research Insights', method: this.testResearchInsights.bind(this) },
      { name: 'Error Handling - Invalid Parameters', method: this.testErrorHandling.bind(this) },
      { name: 'Error Handling - Missing Context', method: this.testMissingContext.bind(this) }
    ];

    for (const test of tests) {
      console.log(`\nüìã ${test.name}`);
      try {
        const result = await test.method();
        this.testResults.push({ name: test.name, success: result.success, details: result });
        if (result.success) {
          console.log('   ‚úÖ PASSED');
          if (result.contextId) {
            this.contextId = result.contextId;
            console.log(`   üîó Context ID: ${result.contextId}`);
          }
        } else {
          console.log('   ‚ùå FAILED');
          console.log(`   üìÑ Details: ${result.error}`);
        }
      } catch (error) {
        console.log('   üí• EXCEPTION');
        console.log(`   üìÑ Error: ${error.message}`);
        this.testResults.push({ name: test.name, success: false, error: error.message });
      }
    }\n\n    this.printSummary();\n  }\n\n  async testBasicAnalysis() {\n    const request = {\n      jsonrpc: '2.0',\n      id: 1,\n      method: 'tools/call',\n      params: {\n        name: 'execute_asr_got_analysis',\n        arguments: {\n          query: 'What are the implications of machine learning in drug discovery?',\n          domain: ['computer_science', 'pharmacology', 'medicine'],\n          complexity_level: 'intermediate',\n          expected_depth: 'detailed',\n          interdisciplinary: true\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    if (response.error) {\n      return { success: false, error: response.error.message };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.success && parsed.result?.context_id) {\n          return { \n            success: true, \n            contextId: parsed.result.context_id,\n            stages: parsed.result.analysis_summary?.stages_completed,\n            nodes: parsed.graph_summary?.total_nodes,\n            errors: parsed.errors?.length || 0\n          };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse response JSON' };\n      }\n    }\n\n    return { success: false, error: 'Invalid response format' };\n  }\n\n  async testStatusCheck() {\n    if (!this.contextId) {\n      return { success: false, error: 'No context ID available from previous test' };\n    }\n\n    const request = {\n      jsonrpc: '2.0',\n      id: 2,\n      method: 'tools/call',\n      params: {\n        name: 'get_analysis_status',\n        arguments: {\n          context_id: this.contextId\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    if (response.error) {\n      return { success: false, error: response.error.message };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.context_id === this.contextId) {\n          return { \n            success: true,\n            stages_completed: parsed.stages_completed,\n            graph_stats: parsed.graph_statistics\n          };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse status response' };\n      }\n    }\n\n    return { success: false, error: 'Invalid status response format' };\n  }\n\n  async testSubgraphExtraction() {\n    if (!this.contextId) {\n      return { success: false, error: 'No context ID available' };\n    }\n\n    const request = {\n      jsonrpc: '2.0',\n      id: 3,\n      method: 'tools/call',\n      params: {\n        name: 'extract_subgraph',\n        arguments: {\n          context_id: this.contextId,\n          criteria: {\n            confidence_threshold: 0.3,\n            impact_threshold: 0.2,\n            node_types: ['hypothesis', 'evidence'],\n            edge_types: ['supportive', 'causal']\n          }\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    if (response.error) {\n      return { success: false, error: response.error.message };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.context_id === this.contextId && parsed.subgraph_summary) {\n          return { \n            success: true,\n            nodes_extracted: parsed.subgraph_summary.nodes_count,\n            edges_extracted: parsed.subgraph_summary.edges_count\n          };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse subgraph response' };\n      }\n    }\n\n    return { success: false, error: 'Invalid subgraph response format' };\n  }\n\n  async testGraphValidation() {\n    if (!this.contextId) {\n      return { success: false, error: 'No context ID available' };\n    }\n\n    const request = {\n      jsonrpc: '2.0',\n      id: 4,\n      method: 'tools/call',\n      params: {\n        name: 'validate_graph_structure',\n        arguments: {\n          context_id: this.contextId,\n          validation_level: 'basic'\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    if (response.error) {\n      return { success: false, error: response.error.message };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.context_id === this.contextId) {\n          return { \n            success: true,\n            is_valid: parsed.is_valid,\n            errors: parsed.errors?.length || 0,\n            warnings: parsed.warnings?.length || 0\n          };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse validation response' };\n      }\n    }\n\n    return { success: false, error: 'Invalid validation response format' };\n  }\n\n  async testResearchInsights() {\n    if (!this.contextId) {\n      return { success: false, error: 'No context ID available' };\n    }\n\n    const request = {\n      jsonrpc: '2.0',\n      id: 5,\n      method: 'tools/call',\n      params: {\n        name: 'get_research_insights',\n        arguments: {\n          context_id: this.contextId,\n          focus_area: 'gaps'\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    if (response.error) {\n      return { success: false, error: response.error.message };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.context_id === this.contextId && parsed.insights) {\n          return { \n            success: true,\n            focus_area: parsed.focus_area,\n            quality_score: parsed.quality_score\n          };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse insights response' };\n      }\n    }\n\n    return { success: false, error: 'Invalid insights response format' };\n  }\n\n  async testErrorHandling() {\n    const request = {\n      jsonrpc: '2.0',\n      id: 6,\n      method: 'tools/call',\n      params: {\n        name: 'execute_asr_got_analysis',\n        arguments: {\n          query: '',  // Invalid empty query\n          domain: 'not_an_array',  // Invalid type\n          complexity_level: 'invalid_level'  // Invalid value\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    // We expect this to either handle gracefully or return proper error\n    if (response.error) {\n      return { success: true, error_handled: true, error_type: 'MCP_error' };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        // Check if error was handled gracefully\n        if (!parsed.success || parsed.result?.fail_safe_activated) {\n          return { success: true, error_handled: true, error_type: 'graceful_degradation' };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse error response' };\n      }\n    }\n\n    return { success: false, error: 'Error not properly handled' };\n  }\n\n  async testMissingContext() {\n    const request = {\n      jsonrpc: '2.0',\n      id: 7,\n      method: 'tools/call',\n      params: {\n        name: 'get_analysis_status',\n        arguments: {\n          context_id: 'non_existent_context_id'\n        }\n      }\n    };\n\n    const response = await this.sendMCPRequest(request);\n    \n    // Should return proper error for missing context\n    if (response.error) {\n      return { success: true, error_handled: true };\n    }\n\n    const content = response.result?.content?.[0];\n    if (content?.type === 'text') {\n      try {\n        const parsed = JSON.parse(content.text);\n        if (parsed.error && parsed.error.includes('not found')) {\n          return { success: true, error_handled: true };\n        }\n      } catch (parseError) {\n        return { success: false, error: 'Failed to parse missing context response' };\n      }\n    }\n\n    return { success: false, error: 'Missing context not properly handled' };\n  }\n\n  async sendMCPRequest(request, timeout = 30000) {\n    return new Promise((resolve, reject) => {\n      const child = spawn('node', ['dist/index.js'], {\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      let output = '';\n      let errorOutput = '';\n      const timeoutId = setTimeout(() => {\n        child.kill();\n        reject(new Error('Request timeout'));\n      }, timeout);\n\n      child.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      child.stderr.on('data', (data) => {\n        errorOutput += data.toString();\n      });\n\n      child.on('close', (code) => {\n        clearTimeout(timeoutId);\n        \n        try {\n          // Parse the last line as JSON response\n          const lines = output.trim().split('\n').filter(line => line.trim());\n          if (lines.length > 0) {\n            const lastLine = lines[lines.length - 1];\n            const response = JSON.parse(lastLine);\n            resolve(response);\n          } else {\n            resolve({ error: { message: 'No output received' } });\n          }\n        } catch (parseError) {\n          resolve({ error: { message: `Parse error: ${parseError.message}. Output: ${output}` } });\n        }\n      });\n\n      child.on('error', (error) => {\n        clearTimeout(timeoutId);\n        reject(error);\n      });\n\n      // Send request\n      child.stdin.write(JSON.stringify(request) + '\\n');\n      child.stdin.end();\n    });\n  }\n\n  printSummary() {\n    console.log('\\nüéØ Test Summary:');\n    console.log('=' .repeat(50));\n    \n    const passed = this.testResults.filter(r => r.success).length;\n    const total = this.testResults.length;\n    \n    console.log(`Total Tests: ${total}`);\n    console.log(`Passed: ${passed}`);\n    console.log(`Failed: ${total - passed}`);\n    console.log(`Success Rate: ${((passed / total) * 100).toFixed(1)}%`);\n    \n    if (passed === total) {\n      console.log('\\nüéâ All tests passed! The MCP server is working correctly.');\n      console.log('\\n‚ú® Key Improvements Verified:');\n      console.log('   ‚Ä¢ Schema validation errors fixed');\n      console.log('   ‚Ä¢ Internal server errors resolved');\n      console.log('   ‚Ä¢ MCP protocol compliance achieved');\n      console.log('   ‚Ä¢ Proper content formatting implemented');\n      console.log('   ‚Ä¢ Context management workflow functional');\n      console.log('   ‚Ä¢ Comprehensive error handling active');\n    } else {\n      console.log('\\n‚ö†Ô∏è  Some tests failed. Check the details above.');\n    }\n  }\n}\n\n// Run the tests\nconst tester = new MCPWorkflowTester();\ntester.runAllTests().catch(console.error);